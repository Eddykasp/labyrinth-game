<canvas id="canvas" width="1200" height="900">
    Your browser doesn't support the canvas element
</canvas>
<script>

var Tile = function(x, y){
    this.x = x;
    this.y = y;
    this.type = 'TILE';
    this.explored = false;
    this.draw = function(){};
}

var TileFloor = function(x, y){
    var tile = new Tile(x, y);
    tile.type = 'TILE_FLOOR';
    tile.draw = function(ctx){
        ctx.fillStyle = '#dbc59e';
        ctx.fillRect(this.x*CELL_WIDTH, this.y*CELL_WIDTH, CELL_WIDTH, CELL_WIDTH);
    }
    return tile;
}

var TileWall = function(x, y){
    var tile = new Tile(x, y);
    tile.type = 'TILE_WALL';
    tile.draw = function(ctx){
        var neighbours = getNeighbouringCells(tile, grid);
        // denotes whether the faces are an edge (left, up, right, down)
        var edges = [true, true, true, true];
        neighbours.forEach(function(cell){
            if(cell.type === 'TILE_WALL'){
                if(cell.x < tile.x){
                    edges[0] = false;
                } else if(cell.x > tile.x){
                    edges[2] = false;
                } else if(cell.y < tile.y){
                    edges[1] = false;
                } else if(cell.y > tile.y){
                    edges[3] = false;
                }
            }
        });
        ctx.fillStyle = '#666';
        ctx.fillRect(this.x*CELL_WIDTH, this.y*CELL_WIDTH, CELL_WIDTH, CELL_WIDTH);
        ctx.fillStyle = '#35281F';
        if(edges[0]){
            ctx.fillRect(this.x*CELL_WIDTH, this.y*CELL_WIDTH, 4, CELL_WIDTH);
        }
        if(edges[1]){
            ctx.fillRect(this.x*CELL_WIDTH, this.y*CELL_WIDTH, CELL_WIDTH, 4);
        }
        if(edges[2]){
            ctx.fillRect((this.x+1)*CELL_WIDTH-4, this.y*CELL_WIDTH, 4, CELL_WIDTH);
        }
        if(edges[3]){
            ctx.fillRect(this.x*CELL_WIDTH, (this.y+1)*CELL_WIDTH - 4, CELL_WIDTH, 4);
        }
    }
    return tile;
}

const CELL_WIDTH = 20;
var canv;
var ctx;
var grid = [];
var gridWidth = 0;
var gridHeight = 0;
var player = {
    x: 0,
    y: 0,
    draw: function(ctx){
        ctx.fillStyle = '#0aa';
        ctx.fillRect(this.x*CELL_WIDTH + 6, this.y*CELL_WIDTH + 6, CELL_WIDTH - 12, CELL_WIDTH - 12);
    },
    move: function(x, y){
        var newX = this.x;
        newX += x;
        var newY = this.y;
        newY += y;

        if(newX < 0){
            newX = gridWidth + newX % gridWidth;
        } else if(newX > gridWidth - 1){
            newX = newX % gridWidth;
        }
        if(newY < 0){
            newY = gridHeight + newY % gridHeight;
        } else if(newY > gridHeight - 1){
            newY = newY % gridHeight;
        }

        if(grid[newX][newY].type === 'TILE_FLOOR'){
            this.x = newX;
            this.y = newY;
        }
    }
}

window.onload = function(){
    canv = document.getElementById('canvas');
    ctx = canv.getContext('2d');

    document.addEventListener('keydown', keyDown);

    init();
    refresh();
    generateMaze(grid);
    window.intervalId = setInterval(update, 1000/30);
};

function init(){
    gridWidth = Math.floor(canv.width/CELL_WIDTH);
    gridHeight = Math.floor(canv.height/CELL_WIDTH);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canv.width, canv.height);
}

function refresh(){
    for(i = 0; i < gridWidth; i++){
        grid.push([]);
        for(j = 0; j < gridHeight; j++){
            grid[i].push(new TileWall(i, j));
        }
    }
}

function update(){
    for(i = 0; i < grid.length; i++){
        for(j = 0; j < grid[i].length; j++){
            //console.log(j);
            grid[i][j].draw(ctx);
        }
    }
    player.draw(ctx);
}

function keyDown(evt){
    switch(evt.keyCode){
    case 37:
        player.move(-1, 0);
        break;
    case 38:
        player.move(0, -1);
        break;
    case 39:
        player.move(1, 0);
        break;
    case 40:
        player.move(0, 1);
        break;
    }
}

function generateMaze(grid){
    var startCell = grid[0][0];
    startCell = new TileFloor(startCell.x, startCell.y);
    grid[0][0] = startCell;
    startCell.explored = true;
    var remainingCells = [];
    getNeighbouringCells(startCell, grid)
        .forEach(function(v){
            remainingCells.push(v)
        });

    while(remainingCells.length !== 0){
        var cell = remainingCells.splice(Math.floor(Math.random()*(remainingCells.length - 1)), 1)[0];
        var cellNeighbours = getNeighbouringCells(cell, grid);
        var exploredNeighboursCount = 0;
        var unexploredNeighbours = [];
        cellNeighbours.forEach(function(v){
            if(v.explored){
                exploredNeighboursCount += 1;
            } else{
                unexploredNeighbours.push(v);
            }
        });
        if(exploredNeighboursCount !== 2){
            cell = new TileFloor(cell.x, cell.y);
            unexploredNeighbours.forEach(function(v){
                remainingCells.push(v);
            });

        }
        cell.explored = true;
        grid[cell.x][cell.y] = cell;
    }
}

function getNeighbouringCells(cell, grid){
    var neighbourList = [];
    if(cell.x > 0){
        neighbourList.push(grid[cell.x-1][cell.y]);
    } else {
        neighbourList.push(grid[gridWidth - 1][cell.y]);
    }
    if(cell.x < gridWidth - 1){
        neighbourList.push(grid[cell.x + 1][cell.y]);
    } else {
        neighbourList.push(grid[0][cell.y]);
    }
    if(cell.y > 0){
        neighbourList.push(grid[cell.x][cell.y - 1]);
    } else {
        neighbourList.push(grid[cell.x][gridHeight - 1]);
    }
    if(cell.y < gridHeight - 1){
        neighbourList.push(grid[cell.x][cell.y + 1]);
    } else {
        neighbourList.push(grid[cell.x][0]);
    }
    return neighbourList;
}

</script>
